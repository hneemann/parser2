package main

import (
	"bytes"
	"io"
	"os"
	"strconv"
)

func writeMethod(w io.StringWriter, d int) {
	gen := ""
	for i := 0; i < d; i++ {
		gen += ", " + string('A'+i)
	}
	w.WriteString("func Method" + strconv.Itoa(d) + "[T" + gen + " value.Value](method func(T" + gen + ", funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {\n")
	w.WriteString(`	switch len(def) {
	case 0:
	  return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
	     defer CatchErr(&e)
	     if obj, ok := stack.Get(0).(T); ok {
	        return method(obj`)
	for i := 0; i < d; i++ {
		w.WriteString(", GetFromStack[" + string('A'+i) + "](stack, " + strconv.Itoa(i+1) + ")")
	}
	w.WriteString(`, stack)
         }
	     return nil, fmt.Errorf("internal error: call of method on wrong type")
	}, Args: ` + strconv.Itoa(d+1) + `, IsPure: true}
`)
	for i := 1; i <= d; i++ {
		w.WriteString(`	case ` + strconv.Itoa(i) + ":\n")
		for j := 0; j < i; j++ {
			v := d - i + j
			w.WriteString("      " + string('a'+v) + " := " + "def[" + strconv.Itoa(j) + "].(" + string('A'+v) + ")\n")
		}
		w.WriteString(`	return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
	     defer CatchErr(&er)
         checkStackM(stack,` + strconv.Itoa(d-i+1) + `,` + strconv.Itoa(d+1) + `)
	     if obj, ok := stack.Get(0).(T); ok {
	        return method(obj`)
		v := d - i
		for j := 0; j < v; j++ {
			w.WriteString(", GetFromStack[" + string('A'+j) + "](stack, " + strconv.Itoa(j+1) + ")")
		}
		for j := v; j < d; j++ {
			w.WriteString(", GetFromStackOptional[" + string('A'+j) + "](stack, " + strconv.Itoa(j+1) + "," + string('a'+j) + ")")
		}
		w.WriteString(`, stack)
         }
	     return nil, fmt.Errorf("internal error: call of method on wrong type")
	}, Args: -1, IsPure: true}
`)
	}
	w.WriteString(`    default:
          panic("internal error: too many default arguments")
	}
}

`)
}

func writeFunction(w io.StringWriter, d int) {
	gen := ""
	for i := 0; i < d; i++ {
		if len(gen) > 0 {
			gen += ", "
		}
		gen += string('A' + i)
	}
	w.WriteString("func Function" + strconv.Itoa(d) + "[" + gen + " value.Value](work func(" + gen + ", funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {\n")
	w.WriteString(`	switch len(def) {
	case 0:
	  return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
	     defer CatchErr(&e)
         return work(`)
	for i := 0; i < d; i++ {
		if i > 0 {
			w.WriteString(", ")
		}
		w.WriteString("GetFromStack[" + string('A'+i) + "](stack, " + strconv.Itoa(i) + ")")
	}
	w.WriteString(`,stack)
	}, Args: ` + strconv.Itoa(d) + `, IsPure: true}
`)
	for i := 1; i <= d; i++ {
		w.WriteString(`	case ` + strconv.Itoa(i) + ":\n")
		for j := 0; j < i; j++ {
			v := d - i + j
			w.WriteString("      " + string('a'+v) + " := " + "def[" + strconv.Itoa(j) + "].(" + string('A'+v) + ")\n")
		}
		w.WriteString(`	return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
	     defer CatchErr(&er)
         checkStackF(stack,` + strconv.Itoa(d-i) + `,` + strconv.Itoa(d) + `)
	        return work(`)
		v := d - i
		for j := 0; j < v; j++ {
			if j > 0 {
				w.WriteString(", ")
			}
			w.WriteString("GetFromStack[" + string('A'+j) + "](stack, " + strconv.Itoa(j) + ")")
		}
		for j := v; j < d; j++ {
			if j > 0 {
				w.WriteString(", ")
			}
			w.WriteString("GetFromStackOptional[" + string('A'+j) + "](stack, " + strconv.Itoa(j) + "," + string('a'+j) + ")")
		}
		w.WriteString(`, stack)
	}, Args: -1, IsPure: true}
`)
	}
	w.WriteString(`    default:
          panic("internal error: too many default arguments")
	}
}

`)
}

func main() {
	var buffer bytes.Buffer
	buffer.WriteString("// Code generated by gen/main.go; DO NOT EDIT.\n\n")
	buffer.WriteString("package arg\n\nimport (\n\t\"fmt\"\n\t\"github.com/hneemann/parser2/funcGen\"\n\t\"github.com/hneemann/parser2/value\"\n)\n\n")
	for d := range 6 {
		writeMethod(&buffer, d+1)
	}
	for d := range 6 {
		writeFunction(&buffer, d+1)
	}
	f, _ := os.Create("generated.go")
	buffer.WriteTo(f)
	f.Close()
}
