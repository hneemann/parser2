// Code generated by gen/main.go; DO NOT EDIT.

package arg

import (
	"fmt"
	"github.com/hneemann/parser2/funcGen"
	"github.com/hneemann/parser2/value"
)

func Method1[T, A value.Value](method func(T, A, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: 2, IsPure: true}
	case 1:
		a := def[0].(A)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 1, 2)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStackOptional[A](stack, 1, a), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Method2[T, A, B value.Value](method func(T, A, B, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: 3, IsPure: true}
	case 1:
		b := def[0].(B)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 2, 3)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStackOptional[B](stack, 2, b), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 2:
		a := def[0].(A)
		b := def[1].(B)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 1, 3)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStackOptional[A](stack, 1, a), GetFromStackOptional[B](stack, 2, b), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Method3[T, A, B, C value.Value](method func(T, A, B, C, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: 4, IsPure: true}
	case 1:
		c := def[0].(C)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 3, 4)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStackOptional[C](stack, 3, c), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 2:
		b := def[0].(B)
		c := def[1].(C)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 2, 4)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStackOptional[B](stack, 2, b), GetFromStackOptional[C](stack, 3, c), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 3:
		a := def[0].(A)
		b := def[1].(B)
		c := def[2].(C)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 1, 4)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStackOptional[A](stack, 1, a), GetFromStackOptional[B](stack, 2, b), GetFromStackOptional[C](stack, 3, c), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Method4[T, A, B, C, D value.Value](method func(T, A, B, C, D, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), GetFromStack[D](stack, 4), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: 5, IsPure: true}
	case 1:
		d := def[0].(D)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 4, 5)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), GetFromStackOptional[D](stack, 4, d), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 2:
		c := def[0].(C)
		d := def[1].(D)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 3, 5)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStackOptional[C](stack, 3, c), GetFromStackOptional[D](stack, 4, d), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 3:
		b := def[0].(B)
		c := def[1].(C)
		d := def[2].(D)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 2, 5)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStackOptional[B](stack, 2, b), GetFromStackOptional[C](stack, 3, c), GetFromStackOptional[D](stack, 4, d), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 4:
		a := def[0].(A)
		b := def[1].(B)
		c := def[2].(C)
		d := def[3].(D)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 1, 5)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStackOptional[A](stack, 1, a), GetFromStackOptional[B](stack, 2, b), GetFromStackOptional[C](stack, 3, c), GetFromStackOptional[D](stack, 4, d), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Method5[T, A, B, C, D, E value.Value](method func(T, A, B, C, D, E, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), GetFromStack[D](stack, 4), GetFromStack[E](stack, 5), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: 6, IsPure: true}
	case 1:
		e := def[0].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 5, 6)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), GetFromStack[D](stack, 4), GetFromStackOptional[E](stack, 5, e), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 2:
		d := def[0].(D)
		e := def[1].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 4, 6)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), GetFromStackOptional[D](stack, 4, d), GetFromStackOptional[E](stack, 5, e), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 3:
		c := def[0].(C)
		d := def[1].(D)
		e := def[2].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 3, 6)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStackOptional[C](stack, 3, c), GetFromStackOptional[D](stack, 4, d), GetFromStackOptional[E](stack, 5, e), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 4:
		b := def[0].(B)
		c := def[1].(C)
		d := def[2].(D)
		e := def[3].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 2, 6)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStackOptional[B](stack, 2, b), GetFromStackOptional[C](stack, 3, c), GetFromStackOptional[D](stack, 4, d), GetFromStackOptional[E](stack, 5, e), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 5:
		a := def[0].(A)
		b := def[1].(B)
		c := def[2].(C)
		d := def[3].(D)
		e := def[4].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 1, 6)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStackOptional[A](stack, 1, a), GetFromStackOptional[B](stack, 2, b), GetFromStackOptional[C](stack, 3, c), GetFromStackOptional[D](stack, 4, d), GetFromStackOptional[E](stack, 5, e), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Method6[T, A, B, C, D, E, F value.Value](method func(T, A, B, C, D, E, F, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), GetFromStack[D](stack, 4), GetFromStack[E](stack, 5), GetFromStack[F](stack, 6), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: 7, IsPure: true}
	case 1:
		f := def[0].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 6, 7)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), GetFromStack[D](stack, 4), GetFromStack[E](stack, 5), GetFromStackOptional[F](stack, 6, f), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 2:
		e := def[0].(E)
		f := def[1].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 5, 7)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), GetFromStack[D](stack, 4), GetFromStackOptional[E](stack, 5, e), GetFromStackOptional[F](stack, 6, f), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 3:
		d := def[0].(D)
		e := def[1].(E)
		f := def[2].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 4, 7)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStack[C](stack, 3), GetFromStackOptional[D](stack, 4, d), GetFromStackOptional[E](stack, 5, e), GetFromStackOptional[F](stack, 6, f), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 4:
		c := def[0].(C)
		d := def[1].(D)
		e := def[2].(E)
		f := def[3].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 3, 7)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStack[B](stack, 2), GetFromStackOptional[C](stack, 3, c), GetFromStackOptional[D](stack, 4, d), GetFromStackOptional[E](stack, 5, e), GetFromStackOptional[F](stack, 6, f), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 5:
		b := def[0].(B)
		c := def[1].(C)
		d := def[2].(D)
		e := def[3].(E)
		f := def[4].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 2, 7)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStack[A](stack, 1), GetFromStackOptional[B](stack, 2, b), GetFromStackOptional[C](stack, 3, c), GetFromStackOptional[D](stack, 4, d), GetFromStackOptional[E](stack, 5, e), GetFromStackOptional[F](stack, 6, f), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	case 6:
		a := def[0].(A)
		b := def[1].(B)
		c := def[2].(C)
		d := def[3].(D)
		e := def[4].(E)
		f := def[5].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackM(stack, 1, 7)
			if obj, ok := stack.Get(0).(T); ok {
				return method(obj, GetFromStackOptional[A](stack, 1, a), GetFromStackOptional[B](stack, 2, b), GetFromStackOptional[C](stack, 3, c), GetFromStackOptional[D](stack, 4, d), GetFromStackOptional[E](stack, 5, e), GetFromStackOptional[F](stack, 6, f), stack)
			}
			return nil, fmt.Errorf("internal error: call of method on wrong type")
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Function1[A value.Value](work func(A, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			return work(GetFromStack[A](stack, 0), stack)
		}, Args: 1, IsPure: true}
	case 1:
		a := def[0].(A)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 0, 1)
			return work(GetFromStackOptional[A](stack, 0, a), stack)
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Function2[A, B value.Value](work func(A, B, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), stack)
		}, Args: 2, IsPure: true}
	case 1:
		b := def[0].(B)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 1, 2)
			return work(GetFromStack[A](stack, 0), GetFromStackOptional[B](stack, 1, b), stack)
		}, Args: -1, IsPure: true}
	case 2:
		a := def[0].(A)
		b := def[1].(B)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 0, 2)
			return work(GetFromStackOptional[A](stack, 0, a), GetFromStackOptional[B](stack, 1, b), stack)
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Function3[A, B, C value.Value](work func(A, B, C, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), stack)
		}, Args: 3, IsPure: true}
	case 1:
		c := def[0].(C)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 2, 3)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStackOptional[C](stack, 2, c), stack)
		}, Args: -1, IsPure: true}
	case 2:
		b := def[0].(B)
		c := def[1].(C)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 1, 3)
			return work(GetFromStack[A](stack, 0), GetFromStackOptional[B](stack, 1, b), GetFromStackOptional[C](stack, 2, c), stack)
		}, Args: -1, IsPure: true}
	case 3:
		a := def[0].(A)
		b := def[1].(B)
		c := def[2].(C)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 0, 3)
			return work(GetFromStackOptional[A](stack, 0, a), GetFromStackOptional[B](stack, 1, b), GetFromStackOptional[C](stack, 2, c), stack)
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Function4[A, B, C, D value.Value](work func(A, B, C, D, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), GetFromStack[D](stack, 3), stack)
		}, Args: 4, IsPure: true}
	case 1:
		d := def[0].(D)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 3, 4)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), GetFromStackOptional[D](stack, 3, d), stack)
		}, Args: -1, IsPure: true}
	case 2:
		c := def[0].(C)
		d := def[1].(D)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 2, 4)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStackOptional[C](stack, 2, c), GetFromStackOptional[D](stack, 3, d), stack)
		}, Args: -1, IsPure: true}
	case 3:
		b := def[0].(B)
		c := def[1].(C)
		d := def[2].(D)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 1, 4)
			return work(GetFromStack[A](stack, 0), GetFromStackOptional[B](stack, 1, b), GetFromStackOptional[C](stack, 2, c), GetFromStackOptional[D](stack, 3, d), stack)
		}, Args: -1, IsPure: true}
	case 4:
		a := def[0].(A)
		b := def[1].(B)
		c := def[2].(C)
		d := def[3].(D)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 0, 4)
			return work(GetFromStackOptional[A](stack, 0, a), GetFromStackOptional[B](stack, 1, b), GetFromStackOptional[C](stack, 2, c), GetFromStackOptional[D](stack, 3, d), stack)
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Function5[A, B, C, D, E value.Value](work func(A, B, C, D, E, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), GetFromStack[D](stack, 3), GetFromStack[E](stack, 4), stack)
		}, Args: 5, IsPure: true}
	case 1:
		e := def[0].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 4, 5)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), GetFromStack[D](stack, 3), GetFromStackOptional[E](stack, 4, e), stack)
		}, Args: -1, IsPure: true}
	case 2:
		d := def[0].(D)
		e := def[1].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 3, 5)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), GetFromStackOptional[D](stack, 3, d), GetFromStackOptional[E](stack, 4, e), stack)
		}, Args: -1, IsPure: true}
	case 3:
		c := def[0].(C)
		d := def[1].(D)
		e := def[2].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 2, 5)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStackOptional[C](stack, 2, c), GetFromStackOptional[D](stack, 3, d), GetFromStackOptional[E](stack, 4, e), stack)
		}, Args: -1, IsPure: true}
	case 4:
		b := def[0].(B)
		c := def[1].(C)
		d := def[2].(D)
		e := def[3].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 1, 5)
			return work(GetFromStack[A](stack, 0), GetFromStackOptional[B](stack, 1, b), GetFromStackOptional[C](stack, 2, c), GetFromStackOptional[D](stack, 3, d), GetFromStackOptional[E](stack, 4, e), stack)
		}, Args: -1, IsPure: true}
	case 5:
		a := def[0].(A)
		b := def[1].(B)
		c := def[2].(C)
		d := def[3].(D)
		e := def[4].(E)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 0, 5)
			return work(GetFromStackOptional[A](stack, 0, a), GetFromStackOptional[B](stack, 1, b), GetFromStackOptional[C](stack, 2, c), GetFromStackOptional[D](stack, 3, d), GetFromStackOptional[E](stack, 4, e), stack)
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}

func Function6[A, B, C, D, E, F value.Value](work func(A, B, C, D, E, F, funcGen.Stack[value.Value]) (value.Value, error), def ...value.Value) funcGen.Function[value.Value] {
	switch len(def) {
	case 0:
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, e error) {
			defer CatchErr(&e)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), GetFromStack[D](stack, 3), GetFromStack[E](stack, 4), GetFromStack[F](stack, 5), stack)
		}, Args: 6, IsPure: true}
	case 1:
		f := def[0].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 5, 6)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), GetFromStack[D](stack, 3), GetFromStack[E](stack, 4), GetFromStackOptional[F](stack, 5, f), stack)
		}, Args: -1, IsPure: true}
	case 2:
		e := def[0].(E)
		f := def[1].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 4, 6)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), GetFromStack[D](stack, 3), GetFromStackOptional[E](stack, 4, e), GetFromStackOptional[F](stack, 5, f), stack)
		}, Args: -1, IsPure: true}
	case 3:
		d := def[0].(D)
		e := def[1].(E)
		f := def[2].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 3, 6)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStack[C](stack, 2), GetFromStackOptional[D](stack, 3, d), GetFromStackOptional[E](stack, 4, e), GetFromStackOptional[F](stack, 5, f), stack)
		}, Args: -1, IsPure: true}
	case 4:
		c := def[0].(C)
		d := def[1].(D)
		e := def[2].(E)
		f := def[3].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 2, 6)
			return work(GetFromStack[A](stack, 0), GetFromStack[B](stack, 1), GetFromStackOptional[C](stack, 2, c), GetFromStackOptional[D](stack, 3, d), GetFromStackOptional[E](stack, 4, e), GetFromStackOptional[F](stack, 5, f), stack)
		}, Args: -1, IsPure: true}
	case 5:
		b := def[0].(B)
		c := def[1].(C)
		d := def[2].(D)
		e := def[3].(E)
		f := def[4].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 1, 6)
			return work(GetFromStack[A](stack, 0), GetFromStackOptional[B](stack, 1, b), GetFromStackOptional[C](stack, 2, c), GetFromStackOptional[D](stack, 3, d), GetFromStackOptional[E](stack, 4, e), GetFromStackOptional[F](stack, 5, f), stack)
		}, Args: -1, IsPure: true}
	case 6:
		a := def[0].(A)
		b := def[1].(B)
		c := def[2].(C)
		d := def[3].(D)
		e := def[4].(E)
		f := def[5].(F)
		return funcGen.Function[value.Value]{Func: func(stack funcGen.Stack[value.Value], closureStore []value.Value) (v value.Value, er error) {
			defer CatchErr(&er)
			checkStackF(stack, 0, 6)
			return work(GetFromStackOptional[A](stack, 0, a), GetFromStackOptional[B](stack, 1, b), GetFromStackOptional[C](stack, 2, c), GetFromStackOptional[D](stack, 3, d), GetFromStackOptional[E](stack, 4, e), GetFromStackOptional[F](stack, 5, f), stack)
		}, Args: -1, IsPure: true}
	default:
		panic("internal error: too many default arguments")
	}
}
